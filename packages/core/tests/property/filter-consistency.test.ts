/**
 * Property-based tests for filter (where clause) consistency.
 *
 * Task 4.1: Create this test file
 * Task 4.2: Property - query with arbitrary where clause returns exact matching subset
 * Task 4.3: Property - query with empty where clause returns all entities
 * Task 4.4: Implement reference matchesWhere function as test oracle
 *
 * These tests verify that the query filter system correctly implements the
 * where clause semantics: no false positives (entities that shouldn't match)
 * and no false negatives (entities that should match but are excluded).
 */
import { Chunk, Effect, Schema, Stream } from "effect";
import * as fc from "fast-check";
import { describe, expect, it } from "vitest";
import { createEffectDatabase } from "../../src/factories/database-effect";
import {
	entityArbitrary,
	getNumRuns,
	type GeneratedWhereClause,
	whereClauseArbitrary,
} from "./generators";

/**
 * Test schema for filter consistency tests.
 * Covers multiple field types to exercise different operator behaviors.
 */
const BookSchema = Schema.Struct({
	id: Schema.String,
	title: Schema.String,
	author: Schema.String,
	year: Schema.Number,
	rating: Schema.Number,
	isPublished: Schema.Boolean,
	tags: Schema.Array(Schema.String),
	scores: Schema.Array(Schema.Number),
});

type Book = Schema.Schema.Type<typeof BookSchema>;

/**
 * Database config for the Book collection.
 */
const config = {
	books: {
		schema: BookSchema,
		relationships: {},
	},
} as const;

describe("Filter consistency properties", () => {
	describe("Task 4.1: Test file structure", () => {
		it("should have access to the required imports and generators", () => {
			// Verify entityArbitrary generates valid entities
			fc.assert(
				fc.property(entityArbitrary(BookSchema), (book) => {
					expect(typeof book.id).toBe("string");
					expect(typeof book.title).toBe("string");
					expect(typeof book.year).toBe("number");
					expect(typeof book.isPublished).toBe("boolean");
					expect(Array.isArray(book.tags)).toBe(true);
				}),
				{ numRuns: 10 },
			);

			// Verify whereClauseArbitrary generates valid where clauses
			fc.assert(
				fc.property(whereClauseArbitrary(BookSchema), (where) => {
					expect(typeof where).toBe("object");
					expect(where).not.toBeNull();
				}),
				{ numRuns: 10 },
			);
		});

		it("should be able to create a database and seed it with entities", async () => {
			const program = Effect.gen(function* () {
				const db = yield* createEffectDatabase(config, {
					books: [
						{
							id: "1",
							title: "Dune",
							author: "Frank Herbert",
							year: 1965,
							rating: 4.5,
							isPublished: true,
							tags: ["sci-fi", "classic"],
							scores: [95, 92, 88],
						},
					],
				});

				const chunk = yield* Stream.runCollect(db.books.query({}));
				const books = Chunk.toReadonlyArray(chunk);
				expect(books).toHaveLength(1);
				expect(books[0].title).toBe("Dune");
			});

			await Effect.runPromise(program);
		});
	});

	describe("Task 4.2: Query with arbitrary where clause returns exact matching subset", () => {
		/**
		 * Helper function to manually check if an entity matches a where clause.
		 * This is a simplified reference implementation used as a test oracle.
		 * It supports the operators generated by whereClauseArbitrary.
		 *
		 * Note: This will be formalized in task 4.4 as matchesWhere().
		 */
		const entityMatchesWhere = (
			entity: Book,
			where: GeneratedWhereClause,
		): boolean => {
			// Empty where clause matches everything
			if (Object.keys(where).length === 0) {
				return true;
			}

			// Check each field condition (AND logic - all must match)
			for (const [fieldName, condition] of Object.entries(where)) {
				const fieldValue = entity[fieldName as keyof Book];

				if (!fieldMatchesCondition(fieldValue, condition)) {
					return false;
				}
			}

			return true;
		};

		/**
		 * Check if a single field value matches a condition.
		 * Handles both direct equality and operator-based conditions.
		 */
		const fieldMatchesCondition = (
			value: unknown,
			condition: unknown,
		): boolean => {
			// Direct equality (no operator)
			if (
				typeof condition !== "object" ||
				condition === null ||
				Array.isArray(condition)
			) {
				return value === condition;
			}

			// Operator-based condition
			const ops = condition as Record<string, unknown>;

			// Multiple operators in the same object = AND logic
			for (const [op, operand] of Object.entries(ops)) {
				if (!evaluateOperator(value, op, operand)) {
					return false;
				}
			}

			return true;
		};

		/**
		 * Evaluate a single operator against a value.
		 */
		const evaluateOperator = (
			value: unknown,
			operator: string,
			operand: unknown,
		): boolean => {
			switch (operator) {
				// Universal operators
				case "$eq":
					return value === operand;
				case "$ne":
					return value !== operand;
				case "$in":
					return Array.isArray(operand) && operand.includes(value);
				case "$nin":
					return Array.isArray(operand) && !operand.includes(value);

				// Comparison operators (numbers and strings)
				case "$gt":
					if (typeof value === "number" && typeof operand === "number") {
						return value > operand;
					}
					if (typeof value === "string" && typeof operand === "string") {
						return value > operand;
					}
					return false;
				case "$gte":
					if (typeof value === "number" && typeof operand === "number") {
						return value >= operand;
					}
					if (typeof value === "string" && typeof operand === "string") {
						return value >= operand;
					}
					return false;
				case "$lt":
					if (typeof value === "number" && typeof operand === "number") {
						return value < operand;
					}
					if (typeof value === "string" && typeof operand === "string") {
						return value < operand;
					}
					return false;
				case "$lte":
					if (typeof value === "number" && typeof operand === "number") {
						return value <= operand;
					}
					if (typeof value === "string" && typeof operand === "string") {
						return value <= operand;
					}
					return false;

				// String operators
				case "$startsWith":
					return (
						typeof value === "string" &&
						typeof operand === "string" &&
						value.startsWith(operand)
					);
				case "$endsWith":
					return (
						typeof value === "string" &&
						typeof operand === "string" &&
						value.endsWith(operand)
					);
				case "$contains":
					// String contains
					if (typeof value === "string" && typeof operand === "string") {
						return value.includes(operand);
					}
					// Array contains
					if (Array.isArray(value)) {
						return value.includes(operand);
					}
					return false;

				// Array operators
				case "$all":
					if (!Array.isArray(value) || !Array.isArray(operand)) {
						return false;
					}
					return operand.every((item) => value.includes(item));
				case "$size":
					return Array.isArray(value) && value.length === operand;

				default:
					// Unknown operator - treat as not matching
					return false;
			}
		};

		it("should return exact matching subset for arbitrary where clauses", async () => {
			await fc.assert(
				fc.asyncProperty(
					// Generate 1-20 entities for the collection
					fc.array(entityArbitrary(BookSchema), { minLength: 1, maxLength: 20 }),
					// Generate an arbitrary where clause
					whereClauseArbitrary(BookSchema),
					async (entities, where) => {
						// Create a fresh database with the generated entities
						const program = Effect.gen(function* () {
							const db = yield* createEffectDatabase(config, {
								books: entities,
							});

							// Query with the generated where clause
							const chunk = yield* Stream.runCollect(
								db.books.query({ where }),
							);
							const queryResults = Chunk.toReadonlyArray(chunk);

							// Calculate expected results using the reference implementation
							const expectedResults = entities.filter((entity) =>
								entityMatchesWhere(entity, where),
							);

							// Verify: same count
							expect(queryResults.length).toBe(expectedResults.length);

							// Verify: same set of IDs (order may differ)
							const queryIds = new Set(queryResults.map((e) => e.id));
							const expectedIds = new Set(expectedResults.map((e) => e.id));
							expect(queryIds).toEqual(expectedIds);

							// Verify: no false inclusions
							for (const result of queryResults) {
								expect(entityMatchesWhere(result, where)).toBe(true);
							}

							// Verify: no false exclusions
							for (const entity of entities) {
								const shouldMatch = entityMatchesWhere(entity, where);
								const wasIncluded = queryIds.has(entity.id);
								expect(wasIncluded).toBe(shouldMatch);
							}
						});

						await Effect.runPromise(program);
					},
				),
				{ numRuns: getNumRuns() },
			);
		});

		it("should handle edge cases: single entity collections", async () => {
			await fc.assert(
				fc.asyncProperty(
					entityArbitrary(BookSchema),
					whereClauseArbitrary(BookSchema),
					async (entity, where) => {
						const program = Effect.gen(function* () {
							const db = yield* createEffectDatabase(config, {
								books: [entity],
							});

							const chunk = yield* Stream.runCollect(
								db.books.query({ where }),
							);
							const queryResults = Chunk.toReadonlyArray(chunk);

							const shouldMatch = entityMatchesWhere(entity, where);

							if (shouldMatch) {
								expect(queryResults.length).toBe(1);
								expect(queryResults[0].id).toBe(entity.id);
							} else {
								expect(queryResults.length).toBe(0);
							}
						});

						await Effect.runPromise(program);
					},
				),
				{ numRuns: getNumRuns() },
			);
		});

		it("should be consistent across multiple queries with the same where clause", async () => {
			await fc.assert(
				fc.asyncProperty(
					fc.array(entityArbitrary(BookSchema), { minLength: 5, maxLength: 15 }),
					whereClauseArbitrary(BookSchema),
					async (entities, where) => {
						const program = Effect.gen(function* () {
							const db = yield* createEffectDatabase(config, {
								books: entities,
							});

							// Run the same query 3 times
							const chunk1 = yield* Stream.runCollect(
								db.books.query({ where }),
							);
							const results1 = Chunk.toReadonlyArray(chunk1);

							const chunk2 = yield* Stream.runCollect(
								db.books.query({ where }),
							);
							const results2 = Chunk.toReadonlyArray(chunk2);

							const chunk3 = yield* Stream.runCollect(
								db.books.query({ where }),
							);
							const results3 = Chunk.toReadonlyArray(chunk3);

							// All queries should return the same results
							const ids1 = new Set(results1.map((e) => e.id));
							const ids2 = new Set(results2.map((e) => e.id));
							const ids3 = new Set(results3.map((e) => e.id));

							expect(ids1).toEqual(ids2);
							expect(ids2).toEqual(ids3);
						});

						await Effect.runPromise(program);
					},
				),
				{ numRuns: getNumRuns() / 2 }, // Fewer runs since we're doing 3x queries
			);
		});
	});

	// Task 4.3 will add: Property tests for empty where clause returning all
	// Task 4.4 will add: Reference matchesWhere implementation as test oracle
});
